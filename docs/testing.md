# Atlas Testing (Modern Approach)

**Last Updated:** 2026-02-12
**Status:** Production-grade testing infrastructure

---

## Quick Start

### Writing Your First Test

```rust
// Use rstest for parameterized tests
use rstest::rstest;
use crate::common::*;  // Helper functions

#[rstest]
#[case("1 + 2", 3.0)]
#[case("10 * 5", 50.0)]
#[case("100 / 4", 25.0)]
fn test_arithmetic(#[case] input: &str, #[case] expected: f64) {
    assert_eval_number(input, expected);
}
```

**That's it!** 3 tests in 7 lines (vs 30+ lines old way).

---

## Testing Tools

### 1. rstest - Parameterized Tests
**Use for:** Same logic, different inputs (90% of tests)

```rust
#[rstest]
#[case("true", true)]
#[case("false", false)]
#[case("true && false", false)]
#[case("true || false", true)]
fn test_bool_eval(#[case] input: &str, #[case] expected: bool) {
    assert_eval_bool(input, expected);
}
```

### 2. insta - Snapshot Testing
**Use for:** Complex outputs (AST, bytecode, diagnostics)

```rust
use insta::assert_yaml_snapshot;

#[test]
fn test_parse_function() {
    let ast = parse("fn add(a: number, b: number) -> number { return a + b; }");
    assert_yaml_snapshot!(ast);  // Auto-generates snapshot file
}
```

**Update snapshots:** `cargo insta review`

### 3. proptest - Property Testing
**Use for:** Invariants, fuzzing, edge cases

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn addition_commutative(a in -1000.0..1000.0, b in -1000.0..1000.0) {
        let ab = eval(&format!("{a} + {b}"));
        let ba = eval(&format!("{b} + {a}"));
        prop_assert_eq!(ab, ba);
    }
}
```

### 4. pretty_assertions
**Use for:** Automatic (imported in `tests/common/mod.rs`)

Shows colored diffs for failed assertions.

---

## Test Helpers

Located in `tests/common/mod.rs`:

```rust
// Evaluation helpers
assert_eval_number("1 + 2", 3.0);
assert_eval_string(r#""hello""#, "hello");
assert_eval_bool("true", true);
assert_eval_null("null");

// Error helpers
assert_error_code("let x: number = \"str\";", "AT0001");
assert_has_error("undefined_var");
assert_no_error("let x = 1;");

// Low-level helpers
let diags = parse_and_get_diagnostics(source);
let bytecode = compile_source(source).unwrap();
let result = run_bytecode(bytecode);
```

---

## Test Organization

```
crates/atlas-runtime/
├── tests/
│   ├── common/
│   │   └── mod.rs              # Shared helpers
│   ├── snapshots/              # Auto-generated by insta
│   │   ├── lexer__*.snap
│   │   └── parser__*.snap
│   ├── lexer_tests_modern.rs   # Modern example
│   ├── interpreter_tests.rs    # To be migrated
│   └── ...
```

---

## Principles

### 1. Deterministic
- No time-based assertions
- No randomness (unless using proptest seed)
- No network calls
- No file system (except test fixtures)

### 2. Table-Driven (Prefer rstest)
**Bad (old way):**
```rust
#[test]
fn test_add() { /* 10 lines */ }
#[test]
fn test_sub() { /* 10 lines */ }
#[test]
fn test_mul() { /* 10 lines */ }
```

**Good (new way):**
```rust
#[rstest]
#[case("1 + 2", 3.0)]
#[case("10 - 5", 5.0)]
#[case("3 * 4", 12.0)]
fn test_arithmetic(#[case] input: &str, #[case] expected: f64) {
    assert_eval_number(input, expected);
}
```

### 3. Snapshots for Complex Output
**Use insta for:**
- AST dumps
- Bytecode disassembly
- Diagnostic messages
- JSON output

### 4. Properties for Invariants
**Use proptest for:**
- Commutativity: `a + b == b + a`
- Associativity: `(a + b) + c == a + (b + c)`
- Parser never panics
- Type checker is deterministic

---

## Examples by Category

### Unit Tests (Lexer)
```rust
#[rstest]
#[case("42", TokenKind::Number)]
#[case("\"hello\"", TokenKind::String)]
#[case("let", TokenKind::Let)]
fn test_token_kinds(#[case] input: &str, #[case] kind: TokenKind) {
    let (tokens, _) = lex(input);
    assert_eq!(tokens[0].kind, kind);
}
```

### Integration Tests (Interpreter)
```rust
#[rstest]
#[case("let x = 5; x", 5.0)]
#[case("var x = 1; x = 10; x", 10.0)]
#[case("if (true) { 42 } else { 0 }", 42.0)]
fn test_control_flow(#[case] input: &str, #[case] expected: f64) {
    assert_eval_number(input, expected);
}
```

### Snapshot Tests (Parser)
```rust
#[test]
fn test_parser_outputs() {
    insta::assert_yaml_snapshot!("simple_expr", parse("1 + 2"));
    insta::assert_yaml_snapshot!("function_decl", parse("fn f() {}"));
    insta::assert_yaml_snapshot!("if_statement", parse("if (x) {}"));
}
```

### Property Tests (Type System)
```rust
proptest! {
    #[test]
    fn type_checker_deterministic(source in ".*") {
        let result1 = typecheck(&source);
        let result2 = typecheck(&source);
        prop_assert_eq!(result1, result2);
    }
}
```

### Error Tests
```rust
#[rstest]
#[case("let x: number = \"str\";", "AT0001")]  // Type mismatch
#[case("unknown_var", "AT0002")]              // Unknown symbol
#[case("let x = 1; x = 2;", "AT0003")]        // Invalid assignment
fn test_type_errors(#[case] source: &str, #[case] code: &str) {
    assert_error_code(source, code);
}
```

---

## Adding a New Test

### Step 1: Choose the Right Tool
- **Same logic, different inputs?** → Use `rstest`
- **Complex output (AST, bytecode)?** → Use `insta`
- **Testing invariants?** → Use `proptest`
- **Simple one-off test?** → Use regular `#[test]`

### Step 2: Use Helpers
Don't write boilerplate. Use `tests/common/mod.rs`:
```rust
assert_eval_number("1 + 2", 3.0);  // Instead of 10 lines
```

### Step 3: Add Cases, Not Tests
**Bad:**
```rust
#[test]
fn test_add_1_2() { ... }
#[test]
fn test_add_5_7() { ... }
```

**Good:**
```rust
#[rstest]
#[case(1, 2, 3)]
#[case(5, 7, 12)]
fn test_add(#[case] a: i32, #[case] b: i32, #[case] expected: i32) { ... }
```

---

## Migration Guide

### Converting Old Tests

**Before (10 lines per test):**
```rust
#[test]
fn test_string_basic() {
    let runtime = Atlas::new();
    let result = runtime.eval(r#""hello""#);
    match result {
        Ok(Value::String(s)) => assert_eq!(s.as_ref(), "hello"),
        _ => panic!("Expected string"),
    }
}
```

**After (1 line):**
```rust
#[rstest]
#[case(r#""hello""#, "hello")]
fn test_strings(#[case] input: &str, #[case] expected: &str) {
    assert_eval_string(input, expected);
}
```

### Converting Golden Tests

**Before (manual files):**
```rust
fn test_golden_file() {
    let expected = std::fs::read_to_string("tests/lexer/numbers.out").unwrap();
    // Manual comparison...
}
```

**After (automatic):**
```rust
#[test]
fn test_lexer_output() {
    let tokens = lex("42 3.14");
    insta::assert_yaml_snapshot!(tokens);
}
```

Run `cargo insta review` to approve snapshots.

---

## CI Integration

### Run Tests
```bash
cargo test --workspace
```

### Review Snapshots (after changes)
```bash
cargo insta review
```

### Check Unused Snapshots
```bash
cargo insta test --unreferenced=delete
```

---

## Performance

### Current Stats
- **1,231 tests** in **~2 seconds**
- Modern tests are FASTER (less setup overhead)
- Snapshots cache results

### Benchmarks
For performance-critical code:
```rust
// benches/lexer_bench.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_lexer(c: &mut Criterion) {
    c.bench_function("lex_arithmetic", |b| {
        b.iter(|| lex(black_box("1 + 2 * 3")))
    });
}

criterion_group!(benches, bench_lexer);
criterion_main!(benches);
```

Run: `cargo bench`

---

## FAQs

### When to use #[test] vs #[rstest]?
- **#[test]:** One-off tests, setup-heavy tests
- **#[rstest]:** When you have 2+ similar tests (99% of cases)

### When to use snapshots vs assertions?
- **Snapshots:** Complex structures (AST, diagnostics, 10+ lines)
- **Assertions:** Simple values (numbers, booleans, short strings)

### How do I debug a failing snapshot?
1. Run `cargo insta review`
2. See old vs new side-by-side
3. Accept if correct, reject if broken

### Should I commit snapshot files?
**Yes!** They're the source of truth for golden tests.

---

## References

- **Modernization Plan:** `docs/TEST_MODERNIZATION_PLAN.md`
- **Helper Functions:** `tests/common/mod.rs`
- **Modern Example:** `tests/lexer_tests_modern.rs`
- **rstest Docs:** https://docs.rs/rstest
- **insta Docs:** https://insta.rs
- **proptest Docs:** https://docs.rs/proptest
