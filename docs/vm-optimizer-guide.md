# Atlas VM Optimizer Guide

**Version:** v0.2 | **Status:** Production Ready

The Atlas VM optimizer applies compile-time transformations to bytecode, improving execution performance without changing program semantics.

---

## Overview

The optimizer runs between the compiler and the VM executor. It takes raw bytecode from the compiler, applies a series of optimization passes, and produces optimized bytecode that is functionally identical but runs faster.

```
Atlas Source
    ↓
  Lexer
    ↓
  Parser
    ↓
  Binder
    ↓
TypeChecker
    ↓
 Compiler  → [Raw Bytecode]
    ↓
 Optimizer → [Optimized Bytecode]
    ↓
  VM Engine
```

---

## Optimization Passes

### 1. Constant Folding

Evaluates constant expressions at compile time, eliminating runtime computation.

**Before:**
```
Constant 3.0
Constant 4.0
Mul
Constant 5.0
Add
```

**After:**
```
Constant 17.0    ← 3 * 4 + 5 evaluated at compile time
```

**What gets folded:**
- Arithmetic: `+`, `-`, `*`, `/`, `%`
- Comparison: `==`, `!=`, `<`, `<=`, `>`, `>=`
- Logic: `!`, `&&`, `||` with constant operands
- String concatenation with constant strings

**Atlas source example:**
```atlas
// This constant expression is fully folded
let circumference = 2 * 3.14159 * 10;   // compiled as: Constant 62.8318
```

---

### 2. Dead Code Elimination

Removes bytecode that can never be executed, reducing code size and improving instruction cache efficiency.

**What gets eliminated:**
- Code after unconditional `return` statements
- Unreachable branches (`if false { ... }`)
- Unused variable assignments where the variable is never read

**Atlas source example:**
```atlas
fn compute() -> number {
    return 42;
    print("never reached");    // eliminated
    return 99;                 // eliminated
}
```

---

### 3. Constant Propagation

Tracks variables assigned constant values and replaces subsequent reads with the constant directly, enabling further folding.

**Before:**
```atlas
let x = 10;
let y = x * 2;    // x is constant → folded to: let y = 20
```

**After:**
```atlas
let y = 20;   // constant propagated and folded
```

---

### 4. Peephole Optimization

Replaces short instruction sequences with more efficient equivalents.

**Examples:**
- `Push 1; Add` → `Increment` (when available)
- `Dup; Pop` → (removed, no-op)
- `Jump L; L:` → (jump removed, label follows immediately)

---

### 5. Jump Threading

Follows chains of jumps and replaces them with direct jumps to the final target.

**Before:**
```
JumpIfFalse L1
Jump L2
L1:
  ...
L2:
  ...
```

**After:**
```
JumpIfFalse L2    ← threaded directly to final target
L1:
  ...
L2:
  ...
```

---

## Using the Optimizer

### Via CLI

The optimizer is enabled by default in production builds:

```bash
atlas run main.atl                  # optimizer enabled (default)
atlas run main.atl --no-optimize    # disable optimizer
atlas build --release               # full optimization
```

### Via Embedding API

```rust
use atlas_runtime::api::{Runtime, ExecutionMode};
use atlas_runtime::optimizer::OptimizationLevel;

// Default: optimizations enabled
let runtime = Runtime::new(ExecutionMode::VM);

// Custom optimization level
let runtime = Runtime::with_config(ExecutionMode::VM, |config| {
    config.optimization_level = OptimizationLevel::Aggressive;
});
```

### Optimization Levels

| Level | Constant Folding | Dead Code | Propagation | Peephole | Jump Threading |
|-------|-----------------|-----------|-------------|---------|----------------|
| `None` | ✗ | ✗ | ✗ | ✗ | ✗ |
| `Basic` (default) | ✓ | ✓ | ✓ | ✓ | ✗ |
| `Aggressive` | ✓ | ✓ | ✓ | ✓ | ✓ |

---

## Performance Impact

Benchmark results from the Atlas v0.2 performance suite:

| Program Type | Speedup (Basic) | Speedup (Aggressive) |
|--------------|----------------|---------------------|
| Math-heavy | 15-25% | 25-40% |
| String manipulation | 5-10% | 8-15% |
| Array operations | 8-15% | 12-20% |
| Control flow heavy | 10-20% | 15-30% |

> **Note:** Speedup percentages are compared to unoptimized VM execution. Actual gains depend on program characteristics.

---

## Verifying Optimization

### Inspect Bytecode

Use the `--dump-bytecode` flag to see the generated bytecode before and after optimization:

```bash
atlas run main.atl --dump-bytecode
atlas run main.atl --dump-bytecode --no-optimize
```

### Benchmark Comparison

```bash
atlas bench main.atl                    # with optimization
atlas bench main.atl --no-optimize      # without optimization
```

---

## Trade-offs

| Consideration | Detail |
|---------------|--------|
| Compilation time | Optimization adds ~5-15% to compile time |
| Memory usage | Slightly more memory during compilation |
| Debug accuracy | Optimized code may have different line mappings |
| Correctness | Optimizer is fully verified for semantic equivalence |

---

## Debugging Optimized Code

When debugging, disable the optimizer to get exact source-to-bytecode mappings:

```bash
atlas debug main.atl --no-optimize
```

The debugger automatically disables optimization for accurate stepping.

---

## Limitations

- **No inlining:** Function inlining is not yet implemented (planned for v0.3)
- **No loop optimization:** Loop unrolling and vectorization are not supported
- **Dynamic dispatch:** Object method calls cannot be statically optimized
- **FFI calls:** Foreign function calls are opaque to the optimizer

---

## Architecture Notes

The optimizer is implemented in `crates/atlas-runtime/src/optimizer/`. It operates on the `Chunk` bytecode structure, iterating instructions and rewriting sequences. Each pass is composable and can be enabled/disabled independently.

```
optimizer/
├── mod.rs           # Optimizer entry point, pass pipeline
├── constant_fold.rs # Constant folding pass
├── dead_code.rs     # Dead code elimination pass
├── propagation.rs   # Constant propagation pass
└── peephole.rs      # Peephole optimization pass
```

---

*See also: [VM Architecture](vm-architecture.md) | [VM Profiler Guide](vm-profiler-guide.md) | [CLI Reference](cli-reference.md)*
