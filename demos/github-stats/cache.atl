// Cache module - Demonstrates File I/O and JSON operations
import { pathJoin } from "std:path";
import { readFile, writeFile, fileExists } from "std:io";
import { parseJSON, toJSON } from "std:json";
import { timestampNow } from "std:datetime";

// Cache duration in seconds (5 minutes)
let CACHE_TTL: number = 300;

fn getCachePath(key: string) -> string {
    return pathJoin(["./data", key + ".json"]);
}

// Check if cache is valid (exists and not expired)
export fn isCacheValid(key: string) -> bool {
    let path: string = getCachePath(key);

    if !fileExists(path) {
        return false;
    }

    let content: Result<string, string> = readFile(path);
    match content {
        Ok(data) -> {
            let json: Result<JsonValue, string> = parseJSON(data);
            match json {
                Ok(obj) -> {
                    let timestamp: JsonValue = obj["timestamp"];
                    let now: number = timestampNow();
                    let cached: number = jsonAsNumber(timestamp);

                    return (now - cached) < CACHE_TTL;
                },
                Err(_) -> return false
            }
        },
        Err(_) -> return false
    }
}

// Get cached data
export fn getCache(key: string) -> Option<JsonValue> {
    if !isCacheValid(key) {
        return None;
    }

    let path: string = getCachePath(key);
    let content: Result<string, string> = readFile(path);

    match content {
        Ok(data) -> {
            let json: Result<JsonValue, string> = parseJSON(data);
            match json {
                Ok(obj) -> {
                    return Some(obj["data"]);
                },
                Err(_) -> return None
            }
        },
        Err(_) -> return None
    }
}

// Set cache data
export fn setCache(key: string, data: JsonValue) -> Result<void, string> {
    let path: string = getCachePath(key);

    // Create cache object with timestamp
    let cacheObj: JsonValue = jsonObject([
        ["timestamp", jsonNumber(timestampNow())],
        ["data", data]
    ]);

    let json: string = toJSON(cacheObj);
    return writeFile(path, json);
}

// Clear specific cache entry
export fn clearCache(key: string) -> void {
    let path: string = getCachePath(key);
    if fileExists(path) {
        // In a real implementation, we'd delete the file
        // For now, we just let it expire naturally
    }
}
