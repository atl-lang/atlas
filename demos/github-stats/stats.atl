// Stats module - Demonstrates Collections, Math, and DateTime operations
import { mapNew, mapSet, mapGet, mapHas, mapKeys } from "std:collections";
import { abs, max } from "std:math";
import { parseIso, diffDays, formatIso, timestampNow } from "std:datetime";

// Calculate total stars across all repos
export fn calculateTotalStars(repos: JsonValue) -> number {
    let total: number = 0;
    let repoArray: array = jsonAsArray(repos);

    for repo in repoArray {
        let stars: JsonValue = repo["stargazers_count"];
        total = total + jsonAsNumber(stars);
    }

    return total;
}

// Calculate total forks
export fn calculateTotalForks(repos: JsonValue) -> number {
    let total: number = 0;
    let repoArray: array = jsonAsArray(repos);

    for repo in repoArray {
        let forks: JsonValue = repo["forks_count"];
        total = total + jsonAsNumber(forks);
    }

    return total;
}

// Find most starred repository
export fn findTopRepo(repos: JsonValue) -> Option<JsonValue> {
    let repoArray: array = jsonAsArray(repos);

    if len(repoArray) == 0 {
        return None;
    }

    let topRepo: JsonValue = repoArray[0];
    let maxStars: number = jsonAsNumber(topRepo["stargazers_count"]);

    for repo in repoArray {
        let stars: number = jsonAsNumber(repo["stargazers_count"]);
        if stars > maxStars {
            maxStars = stars;
            topRepo = repo;
        }
    }

    return Some(topRepo);
}

// Aggregate languages across all repos (returns HashMap)
export fn aggregateLanguages(repos: JsonValue) -> HashMap {
    let languages: HashMap = mapNew();
    let repoArray: array = jsonAsArray(repos);

    for repo in repoArray {
        let lang: JsonValue = repo["language"];

        if !jsonIsNull(lang) {
            let langStr: string = jsonAsString(lang);

            if mapHas(languages, langStr) {
                let count: number = jsonAsNumber(mapGet(languages, langStr));
                mapSet(languages, langStr, jsonNumber(count + 1));
            } else {
                mapSet(languages, langStr, jsonNumber(1));
            }
        }
    }

    return languages;
}

// Find most used language
export fn findTopLanguage(languageMap: HashMap) -> Option<string> {
    let keys: array = mapKeys(languageMap);

    if len(keys) == 0 {
        return None;
    }

    let topLang: string = keys[0];
    let maxCount: number = jsonAsNumber(mapGet(languageMap, topLang));

    for lang in keys {
        let count: number = jsonAsNumber(mapGet(languageMap, lang));
        if count > maxCount {
            maxCount = count;
            topLang = lang;
        }
    }

    return Some(topLang);
}

// Calculate language percentage
export fn calculateLanguagePercentage(languageMap: HashMap, language: string) -> number {
    let keys: array = mapKeys(languageMap);
    let total: number = 0;

    for lang in keys {
        let count: number = jsonAsNumber(mapGet(languageMap, lang));
        total = total + count;
    }

    if total == 0 {
        return 0;
    }

    let count: number = jsonAsNumber(mapGet(languageMap, language));
    return (count / total) * 100;
}

// Calculate days since last activity
export fn daysSinceLastActivity(repos: JsonValue) -> number {
    let repoArray: array = jsonAsArray(repos);

    if len(repoArray) == 0 {
        return 0;
    }

    // Get most recent update (repos are sorted by updated time)
    let firstRepo: JsonValue = repoArray[0];
    let updatedAt: string = jsonAsString(firstRepo["updated_at"]);

    let lastUpdate: Result<DateTime, string> = parseIso(updatedAt);
    match lastUpdate {
        Ok(dt) -> {
            let now: DateTime = timestampNow();
            return abs(diffDays(now, dt));
        },
        Err(_) -> return 0
    }
}

// Calculate contribution streak from events
export fn calculateStreak(events: JsonValue) -> number {
    let eventArray: array = jsonAsArray(events);

    if len(eventArray) == 0 {
        return 0;
    }

    // Simple streak: count consecutive days with events
    let streak: number = 0;
    let lastDate: Option<DateTime> = None;

    for event in eventArray {
        let createdAt: string = jsonAsString(event["created_at"]);
        let eventTime: Result<DateTime, string> = parseIso(createdAt);

        match eventTime {
            Ok(dt) -> {
                match lastDate {
                    None -> {
                        lastDate = Some(dt);
                        streak = 1;
                    },
                    Some(last) -> {
                        let diff: number = abs(diffDays(dt, last));
                        if diff <= 1 {
                            streak = streak + 1;
                            lastDate = Some(dt);
                        }
                    }
                }
            },
            Err(_) -> {}
        }
    }

    return streak;
}

// Count public repositories (exclude forks)
export fn countPublicRepos(repos: JsonValue) -> number {
    let repoArray: array = jsonAsArray(repos);
    let count: number = 0;

    for repo in repoArray {
        let isFork: bool = jsonAsBool(repo["fork"]);
        if !isFork {
            count = count + 1;
        }
    }

    return count;
}
