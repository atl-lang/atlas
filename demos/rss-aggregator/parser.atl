// Parser module - RSS/XML parsing with Regex
import { regexNew, regexFindAll } from "std:regex";
import { parseIso } from "std:datetime";

// Extract text content from XML tag
fn extractTagContent(xml: string, tag: string) -> string {
    let pattern: string = "<" + tag + "[^>]*>([^<]+)</" + tag + ">";
    let regex: Result<Regex, string> = regexNew(pattern);

    match regex {
        Ok(re) -> {
            let matches: array = regexFindAll(re, xml);
            if len(matches) > 0 {
                let firstMatch: JsonValue = matches[0];
                let groups: array = firstMatch["groups"];
                if len(groups) > 1 {
                    return trim(groups[1]);
                }
            }
        },
        Err(_) -> {}
    }

    return "";
}

// Extract CDATA content
fn extractCData(xml: string) -> string {
    let pattern: string = "<!\\[CDATA\\[([^\\]]+)\\]\\]>";
    let regex: Result<Regex, string> = regexNew(pattern);

    match regex {
        Ok(re) -> {
            let matches: array = regexFindAll(re, xml);
            if len(matches) > 0 {
                let firstMatch: JsonValue = matches[0];
                let groups: array = firstMatch["groups"];
                if len(groups) > 1 {
                    return trim(groups[1]);
                }
            }
        },
        Err(_) -> {}
    }

    return xml;
}

// Parse single RSS item
fn parseItem(itemXml: string) -> JsonValue {
    let title: string = extractTagContent(itemXml, "title");
    let link: string = extractTagContent(itemXml, "link");
    let description: string = extractTagContent(itemXml, "description");
    let pubDate: string = extractTagContent(itemXml, "pubDate");

    // Also try dc:date for Atom feeds
    if len(pubDate) == 0 {
        pubDate = extractTagContent(itemXml, "published");
    }

    // Clean CDATA from description
    let cleanDescription: string = extractCData(description);

    return jsonObject([
        ["title", jsonString(title)],
        ["link", jsonString(link)],
        ["description", jsonString(cleanDescription)],
        ["pubDate", jsonString(pubDate)]
    ]);
}

// Parse RSS feed XML
export fn parseFeed(xml: string, feedUrl: string) -> Result<JsonValue, string> {
    // Extract feed metadata
    let feedTitle: string = extractTagContent(xml, "title");
    let feedDescription: string = extractTagContent(xml, "description");

    // Extract all items
    let itemPattern: string = "<item[^>]*>(.*?)</item>";
    let itemRegex: Result<Regex, string> = regexNew(itemPattern);

    let items: array = [];

    match itemRegex {
        Ok(re) -> {
            let matches: array = regexFindAll(re, xml);

            for match in matches {
                let groups: array = match["groups"];
                if len(groups) > 1 {
                    let itemXml: string = groups[1];
                    let item: JsonValue = parseItem(itemXml);

                    // Add feed source
                    let itemWithSource: JsonValue = jsonObject([
                        ["title", item["title"]],
                        ["link", item["link"]],
                        ["description", item["description"]],
                        ["pubDate", item["pubDate"]],
                        ["feedUrl", jsonString(feedUrl)],
                        ["feedTitle", jsonString(feedTitle)]
                    ]);

                    push(items, itemWithSource);
                }
            }
        },
        Err(e) -> return Err("Failed to parse items: " + e)
    }

    // Also try entry for Atom feeds
    if len(items) == 0 {
        let entryPattern: string = "<entry[^>]*>(.*?)</entry>";
        let entryRegex: Result<Regex, string> = regexNew(entryPattern);

        match entryRegex {
            Ok(re) -> {
                let matches: array = regexFindAll(re, xml);

                for match in matches {
                    let groups: array = match["groups"];
                    if len(groups) > 1 {
                        let itemXml: string = groups[1];
                        let item: JsonValue = parseItem(itemXml);

                        let itemWithSource: JsonValue = jsonObject([
                            ["title", item["title"]],
                            ["link", item["link"]],
                            ["description", item["description"]],
                            ["pubDate", item["pubDate"]],
                            ["feedUrl", jsonString(feedUrl)],
                            ["feedTitle", jsonString(feedTitle)]
                        ]);

                        push(items, itemWithSource);
                    }
                }
            },
            Err(_) -> {}
        }
    }

    let feed: JsonValue = jsonObject([
        ["title", jsonString(feedTitle)],
        ["description", jsonString(feedDescription)],
        ["url", jsonString(feedUrl)],
        ["items", jsonArray(items)],
        ["itemCount", jsonNumber(len(items))]
    ]);

    return Ok(feed);
}

// Create article summary
export fn createArticle(title: string, link: string, description: string, pubDate: string, source: string) -> JsonValue {
    return jsonObject([
        ["title", jsonString(title)],
        ["link", jsonString(link)],
        ["description", jsonString(description)],
        ["pubDate", jsonString(pubDate)],
        ["source", jsonString(source)]
    ]);
}
