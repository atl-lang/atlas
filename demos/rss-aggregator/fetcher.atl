// Fetcher module - HTTP feed fetching with caching
import { http_get, http_is_success, http_body } from "std:http";
import { readFile, writeFile, fileExists } from "std:io";
import { pathJoin } from "std:path";
import { parseJSON, toJSON } from "std:json";
import { timestampNow } from "std:datetime";

// Cache TTL: 15 minutes
let CACHE_TTL: number = 900;

fn getCachePath(feedUrl: string) -> string {
    // Create safe filename from URL
    let safe: string = replace(feedUrl, "https://", "");
    safe = replace(safe, "http://", "");
    safe = replace(safe, "/", "-");
    safe = replace(safe, ":", "-");

    return pathJoin(["./cache", safe + ".json"]);
}

// Check if cache is valid
fn isCacheValid(feedUrl: string) -> bool {
    let path: string = getCachePath(feedUrl);

    if (!fileExists(path)) {
        return false;
    }

    let content: Result<string, string> = readFile(path);
    match content {
        Ok(data) => {
            let json: Result<JsonValue, string> = parseJSON(data);
            match json {
                Ok(obj) => {
                    let timestamp: JsonValue = obj["timestamp"];
                    let now: number = timestampNow();
                    let cached: number = jsonAsNumber(timestamp);

                    return (now - cached) < CACHE_TTL;
                },
                Err(_) => return false
            }
        },
        Err(_) => return false
    }
}

// Get cached feed
fn getCache(feedUrl: string) -> Option<string> {
    if (!isCacheValid(feedUrl)) {
        return None;
    }

    let path: string = getCachePath(feedUrl);
    let content: Result<string, string> = readFile(path);

    match content {
        Ok(data) => {
            let json: Result<JsonValue, string> = parseJSON(data);
            match json {
                Ok(obj) => return Some(jsonAsString(obj["data"])),
                Err(_) => return None
            }
        },
        Err(_) => return None
    }
}

// Set cache
fn setCache(feedUrl: string, data: string) -> Result<void, string> {
    let path: string = getCachePath(feedUrl);

    let cacheObj: JsonValue = jsonObject([
        ["timestamp", jsonNumber(timestampNow())],
        ["data", jsonString(data)]
    ]);

    let json: string = toJSON(cacheObj);
    return writeFile(path, json);
}

// Fetch RSS feed
export fn fetchFeed(feedUrl: string) -> Result<string, string> {
    // Check cache first
    let cached: Option<string> = getCache(feedUrl);
    match cached {
        Some(data) => {
            print("  üì¶ Using cached data");
            return Ok(data);
        },
        None => {
            print("  üåê Fetching fresh data...");

            let response: Result<HttpResponse, string> = http_get(feedUrl);

            match response {
                Ok(resp) => {
                    if (http_is_success(resp)) {
                        let body: string = http_body(resp);

                        // Cache the response
                        setCache(feedUrl, body);

                        return Ok(body);
                    } else {
                        return Err("HTTP error");
                    }
                },
                Err(e) => return Err("Failed to fetch feed: " + e)
            }
        }
    }
}
