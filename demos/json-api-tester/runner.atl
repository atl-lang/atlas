// Runner module - Test execution engine
import {
    http_request,
    http_request_get,
    http_request_post,
    http_request_put,
    http_request_delete,
    http_request_patch,
    http_set_header,
    http_set_body,
    http_set_timeout,
    http_send
} from "std:http";
import {
    validateStatus,
    validateHeader,
    validateHeaderContains,
    validateBodyContains,
    validateBodyMatchesRegex,
    validateJsonResponse,
    validateJsonField,
    validateJsonFieldExists
} from "./validator";
import { timestampNow } from "std:datetime";

// Execute a single HTTP request
fn executeRequest(test: JsonValue) -> Result<HttpResponse, string> {
    let method: string = jsonAsString(test["method"]);
    let url: string = jsonAsString(test["url"]);

    // Create request based on method
    let request: Result<HttpRequest, string> = match method {
        "GET" -> http_request_get(url),
        "POST" -> http_request_post(url),
        "PUT" -> http_request_put(url),
        "DELETE" -> http_request_delete(url),
        "PATCH" -> http_request_patch(url),
        _ => return Err("Unsupported HTTP method: " + method)
    };

    let req: HttpRequest = match request {
        Ok(r) => r,
        Err(e) => return Err(e)
    };

    // Add headers if present
    let headers: JsonValue = test["headers"];
    if (!jsonIsNull(headers) && jsonIsObject(headers)) {
        let headerObj: object = jsonAsObject(headers);
        // In real implementation, iterate over object keys
        // For now, handle common headers
        let contentType: JsonValue = headers["Content-Type"];
        if (!jsonIsNull(contentType)) {
            req = http_set_header(req, "Content-Type", jsonAsString(contentType));
        }

        let auth: JsonValue = headers["Authorization"];
        if (!jsonIsNull(auth)) {
            req = http_set_header(req, "Authorization", jsonAsString(auth));
        }
    }

    // Add body if present
    let body: JsonValue = test["body"];
    if (!jsonIsNull(body)) {
        if (jsonIsString(body)) {
            req = http_set_body(req, jsonAsString(body));
        } else {
            // Convert JSON to string
            let bodyStr: string = toJSON(body);
            req = http_set_body(req, bodyStr);
        }
    }

    // Set timeout if present
    let timeout: JsonValue = test["timeout"];
    if (!jsonIsNull(timeout)) {
        req = http_set_timeout(req, jsonAsNumber(timeout));
    }

    // Send request
    return http_send(req);
}

// Run assertions on response
fn runAssertions(response: HttpResponse, assertions: JsonValue) -> array {
    let results: array = [];

    if (jsonIsNull(assertions) || !jsonIsArray(assertions)) {
        return results;
    }

    let assertArr: array = jsonAsArray(assertions);

    for assertion in assertArr {
        let assertType: string = jsonAsString(assertion["type"]);
        let result: Result<void, string> = Ok(void);

        match assertType {
            "status" -> {
                let expected: number = jsonAsNumber(assertion["value"]);
                result = validateStatus(response, expected);
            },
            "header" -> {
                let name: string = jsonAsString(assertion["name"]);
                let value: string = jsonAsString(assertion["value"]);
                result = validateHeader(response, name, value);
            },
            "header_contains" -> {
                let name: string = jsonAsString(assertion["name"]);
                let value: string = jsonAsString(assertion["value"]);
                result = validateHeaderContains(response, name, value);
            },
            "body_contains" -> {
                let text: string = jsonAsString(assertion["value"]);
                result = validateBodyContains(response, text);
            },
            "body_regex" -> {
                let pattern: string = jsonAsString(assertion["value"]);
                result = validateBodyMatchesRegex(response, pattern);
            },
            "json_field" -> {
                let jsonResult: Result<JsonValue, string> = validateJsonResponse(response);
                match jsonResult {
                    Ok(json) => {
                        let field: string = jsonAsString(assertion["field"]);
                        let expected: JsonValue = assertion["value"];
                        result = validateJsonField(json, field, expected);
                    },
                    Err(e) => result = Err(e)
                }
            },
            "json_field_exists" -> {
                let jsonResult: Result<JsonValue, string> = validateJsonResponse(response);
                match jsonResult {
                    Ok(json) => {
                        let field: string = jsonAsString(assertion["field"]);
                        result = validateJsonFieldExists(json, field);
                    },
                    Err(e) => result = Err(e)
                }
            },
            _ => result = Err("Unknown assertion type: " + assertType)
        }

        // Store result
        let assertionResult: JsonValue = match result {
            Ok(_) => jsonObject([
                ["type", jsonString(assertType)],
                ["passed", jsonBool(true)],
                ["message", jsonString("Passed")]
            ]),
            Err(e) => jsonObject([
                ["type", jsonString(assertType)],
                ["passed", jsonBool(false)],
                ["message", jsonString(e)]
            ])
        };

        push(results, assertionResult);
    }

    return results;
}

// Run a single test
export fn runTest(test: JsonValue) -> JsonValue {
    let name: string = jsonAsString(test["name"]);
    let startTime: number = timestampNow();

    // Execute request
    let response: Result<HttpResponse, string> = executeRequest(test);

    match response {
        Ok(resp) => {
            // Run assertions
            let assertions: JsonValue = test["assertions"];
            let assertionResults: array = runAssertions(resp, assertions);

            // Check if all passed
            let allPassed: bool = true;
            for result in assertionResults {
                let passed: bool = jsonAsBool(result["passed"]);
                if (!passed) {
                    allPassed = false;
                }
            }

            let endTime: number = timestampNow();
            let duration: number = endTime - startTime;

            return jsonObject([
                ["name", jsonString(name)],
                ["passed", jsonBool(allPassed)],
                ["duration", jsonNumber(duration)],
                ["status", jsonNumber(http_status(resp))],
                ["assertions", jsonArray(assertionResults)],
                ["error", jsonNull()]
            ]);
        },
        Err(e) => {
            let endTime: number = timestampNow();
            let duration: number = endTime - startTime;

            return jsonObject([
                ["name", jsonString(name)],
                ["passed", jsonBool(false)],
                ["duration", jsonNumber(duration)],
                ["status", jsonNull()],
                ["assertions", jsonArray([])],
                ["error", jsonString(e)]
            ]);
        }
    }
}
