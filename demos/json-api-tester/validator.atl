// Validator module - Response validation and assertions
import { http_status, http_body, http_header, http_headers } from "std:http";
import { parseJSON } from "std:json";
import { regexNew, regexTest } from "std:regex";

// Validate HTTP status code
export fn validateStatus(response: HttpResponse, expected: number) -> Result<void, string> {
    let actual: number = http_status(response);

    if (actual == expected) {
        return Ok(void);
    } else {
        return Err("Status mismatch: expected " + toString(expected) + ", got " + toString(actual));
    }
}

// Validate response header exists and matches value
export fn validateHeader(response: HttpResponse, headerName: string, expectedValue: string) -> Result<void, string> {
    let actual: string = http_header(response, headerName);

    if (actual == expectedValue) {
        return Ok(void);
    } else {
        return Err("Header '" + headerName + "' mismatch: expected '" + expectedValue + "', got '" + actual + "'");
    }
}

// Validate header contains value
export fn validateHeaderContains(response: HttpResponse, headerName: string, substring: string) -> Result<void, string> {
    let actual: string = http_header(response, headerName);

    if (contains(actual, substring)) {
        return Ok(void);
    } else {
        return Err("Header '" + headerName + "' does not contain '" + substring + "'");
    }
}

// Validate response body matches exact string
export fn validateBodyEquals(response: HttpResponse, expected: string) -> Result<void, string> {
    let actual: string = http_body(response);

    if (actual == expected) {
        return Ok(void);
    } else {
        return Err("Body mismatch: expected '" + expected + "', got '" + actual + "'");
    }
}

// Validate response body contains substring
export fn validateBodyContains(response: HttpResponse, substring: string) -> Result<void, string> {
    let actual: string = http_body(response);

    if (contains(actual, substring)) {
        return Ok(void);
    } else {
        return Err("Body does not contain '" + substring + "'");
    }
}

// Validate response body matches regex
export fn validateBodyMatchesRegex(response: HttpResponse, pattern: string) -> Result<void, string> {
    let actual: string = http_body(response);
    let regex: Result<Regex, string> = regexNew(pattern);

    match regex {
        Ok(re) => {
            if (regexTest(re, actual)) {
                return Ok(void);
            } else {
                return Err("Body does not match pattern '" + pattern + "'");
            }
        },
        Err(e) => return Err("Invalid regex pattern: " + e)
    }
}

// Validate response is valid JSON
export fn validateJsonResponse(response: HttpResponse) -> Result<JsonValue, string> {
    let body: string = http_body(response);
    let json: Result<JsonValue, string> = parseJSON(body);

    match json {
        Ok(data) => return Ok(data),
        Err(e) => return Err("Invalid JSON response: " + e)
    }
}

// Validate JSON field exists and has specific value
export fn validateJsonField(json: JsonValue, field: string, expectedValue: JsonValue) -> Result<void, string> {
    let actual: JsonValue = json[field];

    if (jsonEquals(actual, expectedValue)) {
        return Ok(void);
    } else {
        let actualStr: string = toJSON(actual);
        let expectedStr: string = toJSON(expectedValue);
        return Err("JSON field '" + field + "' mismatch: expected " + expectedStr + ", got " + actualStr);
    }
}

// Validate JSON field exists
export fn validateJsonFieldExists(json: JsonValue, field: string) -> Result<void, string> {
    let value: JsonValue = json[field];

    if (jsonIsNull(value)) {
        return Err("JSON field '" + field + "' does not exist or is null");
    } else {
        return Ok(void);
    }
}

// Validate JSON array length
export fn validateJsonArrayLength(json: JsonValue, expectedLength: number) -> Result<void, string> {
    if (!jsonIsArray(json)) {
        return Err("Expected JSON array, got " + reflect_typeof(json));
    }

    let arr: array = jsonAsArray(json);
    let actualLength: number = len(arr);

    if (actualLength == expectedLength) {
        return Ok(void);
    } else {
        return Err("Array length mismatch: expected " + toString(expectedLength) + ", got " + toString(actualLength));
    }
}
